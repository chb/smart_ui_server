C({"name": "jQuery.Class", "children": [{"name": "jQuery.Class.static", "shortName": "static", "title": undefined, "hide": false}, {"name": "jQuery.Class.static.callback", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Class.static.getObject", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Class.static.extend", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Class.static.newInstance", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Class.static.fullName", "shortName": "attribute", "title": undefined, "hide": false}, {"name": "jQuery.Class.prototype", "shortName": "prototype", "title": undefined, "hide": false}, {"name": "jQuery.Class.prototype.init", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Class.prototype.Class", "shortName": "attribute", "title": undefined, "hide": false}, {"name": "jQuery.Class.prototype.callback", "shortName": "function", "title": undefined, "hide": false}], "comment": " Class provides simulated inheritance in JavaScript. \n It is based off John Resig's [http://ejohn.org/blog/simple-javascript-inheritance/|Simple Class] \n Inheritance library.  Besides prototypal inheritance, it adds a few important features:\n <ul>\n     <li>Static inheritance</li>\n     <li>Introspection</li>\n     <li>Ad-Hoc Polymorphism</li>\n     <li>Easy callback function creation</li>\n </ul>\n <h2>Definitions</h2>\n Classes have <b>static</b> and <b>prototype</b> properties and\n methods:\n<pre><code class='javascript'> //STATIC\n MyClass.staticProperty  //shared property\n \n //PROTOTYPE\n myclass = new MyClass()\n myclass.prototypeMethod() //instance method</code></pre> \n <h2>Examples</h2>\n <h3>Basic example</h3>\n Creates a class with a shortName (for introspection), static, and prototype members:\n<pre><code class='javascript'> jQuery.Class.extend('Monster',\n /* @static */\n {\n   count: 0\n },\n /* @prototype */\n {\n   init : function(name){\n     this.name = name;\n     this.Class.count++\n   }\n })\n hydra = new Monster('hydra')\n dragon = new Monster('dragon')\n hydra.name        // -> hydra\n Monster.count     // -> 2\n Monster.shortName // -> 'Monster'</code></pre> Notice that the prototype init function is called when a new instance of Monster is created.\n <h3>Static property inheritance</h3>\n Demonstrates inheriting a class property.\n<pre><code class='javascript'> jQuery.Class.extend(\"First\",\n {\n     staticMethod : function(){ return 1;}\n },{})\n \n First.extend(\"Second\",{\n     staticMethod : function(){ return this._super()+1;}\n },{})\n \n Second.staticMethod() // -> 2</code></pre> <h3 id='introspection'>Introspection</h3>\n Often, it's nice to create classes whose name helps determine functionality.  Ruby on\n Rails's [http://api.rubyonrails.org/classes/ActiveRecord/Base.html|ActiveRecord] ORM class \n is a great example of this.  Unfortunately, JavaScript doesn't have a way of determining\n an object's name, so the developer must provide a name.  Class fixes this by taking a String name for the class.\n<pre><code class='javascript'> $.Class.extend(\"MyOrg.MyClass\",{},{})\n MyOrg.MyClass.shortName //-> 'MyClass'\n MyOrg.MyClass.fullName //->  'MyOrg.MyClass'</code></pre> <h3>Construtors</h3>\n Class uses static and class initialization constructor functions.  \n<pre><code class='javascript'> $.Class.extend(\"MyClass\",\n {\n   init: function(){} //static constructor\n },\n {\n   init: function(){} //prototype constructor\n })</code></pre> <p>The static constructor is called after\n a class has been created.  \n This is a good place to add introspection and similar class setup code.</p>\n \n <p>The prototype constructor is called whenever a new instance of the class is created.\n </p>\n \n \n <h3 id='ad-hoc'>Ad-Hoc Polymorphism</h3>\n <p>Ad-Hoc Polymorphism allows you to create parameterized, temporary \n    classes.  This is a technique commonly used in Static languages where\n    you might create map of Strings to Integers like:\n<pre><code class='text'> Hash&lt;string, int> hash = new Hash&lt;string, int>()</code></pre> With Class, Ad-Hoc Polymorphism is used to configure Classs.\n Here's a simplistic example:\n<pre><code class='javascript'> $.Class.extend(\"Request\",\n {\n    init : function(url){\n       $.getScript(this.Class.OPTIONS.domain+\"/\"+url)  \n    }\n });\n var JMVCRequestor = Request({domain: \"http://javascriptmvc.com\"})\n new JMVCRequestor(\"jmvc.js\");</code></pre> Ad-Hoc techniques are used a lot with Controller to customize and\n combine widgets.\n \n", "shortName": "Constructor", "ret": {"type": "undefined", "description": ""}, "params": {}, "plugin": "jquery/class"})